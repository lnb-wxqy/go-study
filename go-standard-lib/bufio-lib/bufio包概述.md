一、bufio的原理
1.概述
 bufio实现了带缓冲的I/O操作，达到高效io读写
    bufio缓冲
    io：input/output
  bufio包封装了一个Reader和Writer结构体对象
  bufio包中的Reader及Writer结构体分别实现了io.Reader和io.Writer接口
  bufio包对io包下Reader及Writer结构体进行包装，通过对io模块的封装，提供了数据缓冲功能，能够一定程度较少大块数据读写带来的开销，所以bufio比io读写更快
 
 2.bufio是通过缓冲来提高效率
    a.把文件读取进缓冲区之后，再读取的时候就可以避免⽂文件系统的io ，从⽽而提高速度；
    b.在进⾏行行写操作时，先把⽂文件写⼊入缓冲区，然后由缓冲写⼊入⽂文件系统。
    c.缓冲区的设计是为了了存储多次的写⼊入，最后⼀口气把缓冲区内容写入文件。
    d.当发起一次读写操作时，会首先尝试从缓冲区获取数据；只有当缓冲区没有数据时，才会从数据源获取数据更更新缓冲。
    
  3.bufio.Read(p []byte)相当于读取大小len(p)的内容，思路如下：
    当缓冲区有内容时，将缓冲区内容全部填入p并清空缓冲区
    当缓冲区没有内容的时候且len(p)>len(buf)，即要读取的内容比缓冲区还要大，直接去⽂文件读取即可
    当缓冲区没有内容的时候且len(p)<len(buf)，即要读取的内容⽐比缓冲区⼩，缓冲区从⽂文件读取内容充满缓冲区，
    并将p填满（此时缓冲区有剩余内容）
    以后再次读取时缓冲区有内容，将缓冲区内容全部填入p并清空缓存冲（此时和情况1⼀一样）
   
  4. bufio.Write(p []byte)的思路:
     判断buf中可⽤用容量是否可以放下 p
     如果能放下，直接把p拼接到buf后⾯面，即把内容放到缓冲区
     如果缓冲区的可用容量不足以放下，且此时缓冲区是空的，直接把p写⼊入文件即可
     如果缓冲区的可⽤用容量不足以放下，且此时缓冲区有内容，则用p把缓冲区填满，把缓冲区所有内容写⼊文件，并清空缓冲区
     判断p的剩余内容⼤小能否放到缓冲区，如果能放下（此时和步骤1情况一样）则把内容放到缓冲区
     如果p的剩余内容依旧⼤大于缓冲区，（注意此时缓冲区是空的，情况和步骤2一样）则把p的剩余内容直接写⼊文件
     
